# Cursor Rules for Omni-CMS

## MCP Documentation Maintenance

**CRITICAL**: When making changes to API routes, you MUST update the MCP documentation in `apps/api/src/routes/public/mcp.ts`.

### When to Update MCP Documentation

Update the MCP documentation (`apps/api/src/routes/public/mcp.ts`) whenever you:

1. **Add a new route endpoint** - Add complete documentation including:
   - Method (GET, POST, PATCH, DELETE, etc.)
   - Path with all parameters
   - Description
   - Authentication requirements
   - Query parameters (if any)
   - Request body fields (if any)
   - Response structure
   - Any special notes or warnings

2. **Modify an existing endpoint** - Update documentation for:
   - New query parameters
   - New request body fields
   - Changed response structure
   - Changed authentication requirements
   - Changed path or method

3. **Remove an endpoint** - Remove from MCP documentation

4. **Add major features** - Document:
   - New query parameter options
   - New response fields
   - New error responses
   - Breaking changes

### MCP Documentation Structure

The MCP documentation follows this structure:
- `endpoints.admin.{resource}.{action}` - Admin endpoints
- `endpoints.public.{resource}.{action}` - Public endpoints

Each endpoint should include:
- `method`: HTTP method
- `path`: Full path with parameters
- `description`: Clear description
- `auth`: 'required', 'optional', or 'none'
- `params`: Array of path parameters
- `queryParams`: Object or array of query parameters with descriptions
- `body`: Object describing request body fields
- `response`: Description of response structure
- `includes`: Relations included in response (if applicable)
- `note`: Any special notes or warnings

### Verification Checklist

Before committing route changes, verify:
- [ ] All new endpoints are documented in MCP
- [ ] All modified endpoints have updated MCP documentation
- [ ] Query parameters are documented with types and defaults
- [ ] Request body fields are documented with types and requirements
- [ ] Response structures are documented
- [ ] Authentication requirements are accurate
- [ ] Special notes or warnings are included

### Example Update Pattern

When adding a new endpoint:
1. Implement the route in the appropriate route file
2. Immediately update `apps/api/src/routes/public/mcp.ts` with complete documentation
3. Test the endpoint
4. Verify MCP documentation matches implementation

## Code Style

- Use TypeScript strict mode
- Follow existing code patterns and conventions
- Use Hono framework patterns consistently
- Document complex logic with comments

## Testing

- Test all new endpoints before committing
- Verify authentication and authorization work correctly
- Test error cases and edge cases
- Ensure MCP documentation matches actual behavior

## useEffect Infinite Loop Prevention

**CRITICAL**: When using `useEffect` with API calls or state updates, you MUST prevent infinite loops.

### Common Causes of Infinite Loops

1. **Function dependencies that aren't memoized** - Functions recreated on every render
2. **Object/array dependencies** - New object/array references on every render
3. **State updates that trigger the effect** - Setting state inside useEffect that's in dependencies
4. **Missing cleanup** - Not canceling requests when component unmounts

### Best Practices

#### 1. Dependency Array Guidelines

- **DO**: Only include values that should trigger the effect
- **DO**: Omit stable functions that are memoized with `useCallback`
- **DON'T**: Include functions from custom hooks unless they're guaranteed stable
- **DON'T**: Include object/array literals or inline functions

```typescript
// ✅ GOOD: Only include pathname that should trigger effect
useEffect(() => {
  fetchData();
}, [pathname]); // handleError is stable via useCallback, omit it

// ❌ BAD: Including function that may be recreated
useEffect(() => {
  fetchData();
}, [pathname, handleError]); // handleError may cause re-renders
```

#### 2. API Calls in useEffect

**Always use these patterns for API calls:**

```typescript
// ✅ GOOD: With fetch guards and AbortController
useEffect(() => {
  const abortController = new AbortController();
  const isFetchingRef = useRef(false);
  const hasFetchedRef = useRef(false);

  // Guard: Prevent multiple simultaneous requests
  if (isFetchingRef.current) return;
  
  // Guard: Early return if already fetched
  if (hasFetchedRef.current && data.length > 0) return;

  isFetchingRef.current = true;

  const fetchData = async () => {
    try {
      const response = await apiClient.getData();
      if (abortController.signal.aborted) return;
      
      setData(response.data);
      hasFetchedRef.current = true;
    } catch (error) {
      if (abortController.signal.aborted) return;
      handleError(error);
    } finally {
      isFetchingRef.current = false;
    }
  };

  fetchData();

  // Cleanup: Abort request on unmount or effect re-run
  return () => {
    abortController.abort();
    isFetchingRef.current = false;
  };
}, [pathname]); // Minimal dependencies
```

#### 3. Required Guards for API Calls

**Always include these guards:**

1. **Fetching guard** - Prevent multiple simultaneous requests:
   ```typescript
   const isFetchingRef = useRef(false);
   if (isFetchingRef.current) return;
   isFetchingRef.current = true;
   ```

2. **Already fetched guard** - Skip if data already loaded:
   ```typescript
   const hasFetchedRef = useRef(false);
   if (hasFetchedRef.current && data.length > 0) return;
   ```

3. **AbortController** - Cancel requests on cleanup:
   ```typescript
   const abortController = new AbortController();
   return () => abortController.abort();
   ```

#### 4. Stable Function Dependencies

**For functions from custom hooks or props:**

```typescript
// ✅ GOOD: Omit if function is memoized with useCallback
const { handleError } = useErrorHandler(); // Memoized internally
useEffect(() => {
  // Use handleError here, but don't include in deps
}, [pathname]);

// ✅ GOOD: Use ref to access latest function without dependency
const handleErrorRef = useRef(handleError);
handleErrorRef.current = handleError;
useEffect(() => {
  // Use handleErrorRef.current
}, [pathname]);
```

#### 5. Cleanup Functions

**Always provide cleanup for:**
- AbortController for API requests
- Timers (setTimeout, setInterval)
- Event listeners
- Subscriptions

```typescript
useEffect(() => {
  const abortController = new AbortController();
  const timer = setTimeout(() => {}, 1000);
  
  return () => {
    abortController.abort();
    clearTimeout(timer);
  };
}, [deps]);
```

### Verification Checklist

Before committing useEffect changes, verify:
- [ ] Dependency array only includes values that should trigger re-runs
- [ ] Functions in dependencies are memoized with useCallback/useMemo
- [ ] Fetch guards prevent multiple simultaneous requests
- [ ] AbortController cancels requests on cleanup
- [ ] Cleanup function aborts requests and clears timers/subscriptions
- [ ] Early returns prevent unnecessary re-fetches

### Anti-Patterns to Avoid

```typescript
// ❌ BAD: Function dependency that's not memoized
useEffect(() => {
  fetchData();
}, [fetchData]); // fetchData recreated on every render

// ❌ BAD: Missing fetch guards
useEffect(() => {
  fetchData(); // Can trigger infinite loop
}, [someValue]);

// ❌ BAD: State update that triggers effect
useEffect(() => {
  setCount(count + 1); // Infinite loop if count is in deps
}, [count]);

// ❌ BAD: Object/array literal in dependencies
useEffect(() => {
  fetchData(options);
}, [options]); // New object reference every render
```

