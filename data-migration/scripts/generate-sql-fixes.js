/**
 * Generate SQL Fixes
 * 
 * Reads cached DB data and comparison report, then generates SQL statements
 * to fix missing relationships and data gaps.
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Load cached data and comparison report
 */
async function loadData(orgSlug) {
  const cacheDir = path.join(__dirname, `../organizations/${orgSlug}/db-cache`);
  const reportPath = path.join(__dirname, `../organizations/${orgSlug}/comparison-report.json`);

  const [postsData, taxonomiesData, relationshipsData, comparisonData] = await Promise.all([
    fs.readFile(path.join(cacheDir, 'posts.json'), 'utf-8').then(JSON.parse).catch(() => ({})),
    fs.readFile(path.join(cacheDir, 'taxonomies.json'), 'utf-8').then(JSON.parse).catch(() => []),
    fs.readFile(path.join(cacheDir, 'relationships.json'), 'utf-8').then(JSON.parse).catch(() => []),
    fs.readFile(reportPath, 'utf-8').then(JSON.parse).catch(() => ({})),
  ]);

  return { postsData, taxonomiesData, relationshipsData, comparisonData };
}

/**
 * Generate SQL for missing post relationships
 */
function generateRelationshipSQL(missingRelationships) {
  const sqlStatements = [];
  
  sqlStatements.push('-- Missing Post Relationships');
  sqlStatements.push('-- Programs without university relationships\n');

  if (missingRelationships.length === 0) {
    sqlStatements.push('-- No missing relationships found\n');
    return sqlStatements;
  }

  sqlStatements.push('-- Insert missing program-university relationships');
  sqlStatements.push('-- Table: post_relationships');
  sqlStatements.push('-- Columns: id (auto-generated), from_post_id, to_post_id, relationship_type, created_at');
  sqlStatements.push('-- Note: id will be auto-generated by nanoid() function\n');

  for (const rel of missingRelationships) {
    sqlStatements.push(`-- ${rel.programTitle} -> ${rel.universityTitle}`);
    sqlStatements.push(`INSERT INTO post_relationships (from_post_id, to_post_id, relationship_type, created_at)`);
    sqlStatements.push(`VALUES ('${rel.programId}', '${rel.universityId}', 'university', strftime('%s', 'now'));`);
    sqlStatements.push('');
  }

  return sqlStatements;
}

/**
 * Generate SQL for missing taxonomy term assignments
 * Note: This requires knowing the post_taxonomy_assignments table structure
 */
function generateTaxonomyAssignmentSQL(comparisonData, postsData, taxonomiesData) {
  const sqlStatements = [];
  
  sqlStatements.push('-- Missing Taxonomy Term Assignments');
  sqlStatements.push('-- Note: Adjust table/column names based on your schema\n');

  // This is a placeholder - actual implementation would need to:
  // 1. Compare which posts should have which taxonomy terms
  // 2. Check which assignments are missing
  // 3. Generate INSERT statements

  sqlStatements.push('-- Example format (adjust based on your schema):');
  sqlStatements.push('-- INSERT INTO post_taxonomy_assignments (post_id, taxonomy_term_id, created_at)');
  sqlStatements.push('-- VALUES (post_id, term_id, datetime(\'now\'));\n');

  sqlStatements.push('-- TODO: Implement taxonomy assignment comparison\n');

  return sqlStatements;
}

/**
 * Generate summary report
 */
function generateSummarySQL(comparisonData) {
  const sqlStatements = [];
  
  sqlStatements.push('-- ============================================================');
  sqlStatements.push('-- SQL Fixes Summary');
  sqlStatements.push('-- ============================================================\n');
  
  sqlStatements.push(`-- Generated: ${new Date().toISOString()}\n`);
  
  sqlStatements.push('-- Statistics:');
  sqlStatements.push(`-- Posts in DB: ${comparisonData.posts?.total_db || 0}`);
  sqlStatements.push(`-- Posts in Transformed Data: ${comparisonData.posts?.total_transformed || 0}`);
  sqlStatements.push(`-- Missing Posts in DB: ${comparisonData.posts?.missing_in_db?.length || 0}`);
  sqlStatements.push(`-- Missing Relationships: ${comparisonData.relationships?.missing_program_university?.length || 0}\n`);

  return sqlStatements;
}

/**
 * Main SQL generation function
 */
export async function generateSQLFixes(orgSlug) {
  console.log(`\nüìù Generating SQL fixes for: ${orgSlug}`);

  const { postsData, taxonomiesData, relationshipsData, comparisonData } = await loadData(orgSlug);

  const sqlStatements = [];

  // Add summary
  sqlStatements.push(...generateSummarySQL(comparisonData));

  // Add relationship fixes
  if (comparisonData.relationships?.missing_program_university) {
    sqlStatements.push(...generateRelationshipSQL(comparisonData.relationships.missing_program_university));
  }

  // Add taxonomy assignment fixes
  sqlStatements.push(...generateTaxonomyAssignmentSQL(comparisonData, postsData, taxonomiesData));

  // Add warnings
  sqlStatements.push('-- ============================================================');
  sqlStatements.push('-- IMPORTANT NOTES');
  sqlStatements.push('-- ============================================================');
  sqlStatements.push('-- 1. Review all SQL statements before executing');
  sqlStatements.push('-- 2. Backup your database before running these statements');
  sqlStatements.push('-- 3. Adjust table/column names based on your actual schema');
  sqlStatements.push('-- 4. Some statements may need to be run in a specific order');
  sqlStatements.push('-- 5. Check for duplicate relationships before inserting\n');

  // Write SQL file
  const sqlPath = path.join(__dirname, `../organizations/${orgSlug}/sql-fixes.sql`);
  await fs.writeFile(sqlPath, sqlStatements.join('\n'));

  console.log(`   ‚úì SQL fixes generated: ${sqlPath}`);
  console.log(`   ‚úì ${comparisonData.relationships?.missing_program_university?.length || 0} relationship fixes`);
  console.log(`\n   ‚ö† Review the SQL file before executing!\n`);

  return sqlPath;
}

/**
 * CLI execution
 */
async function main() {
  const orgSlug = process.argv[2] || 'study-in-north-cyprus';

  try {
    await generateSQLFixes(orgSlug);
  } catch (error) {
    console.error('Error:', error.message);
    process.exit(1);
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

